"use strict";
// Copyright 2023 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleTokenScheme = exports.TokenSchemeType = exports.TokenScheme = exports.TokenSchemeDiscriminator = void 0;
const class_transformer_1 = require("class-transformer");
const hex_encoding_1 = require("../../utils/hex-encoding");
/**
 * All of the token scheme types.
 */
var TokenSchemeType;
(function (TokenSchemeType) {
    /** A simple token scheme. */
    TokenSchemeType[TokenSchemeType["Simple"] = 0] = "Simple";
})(TokenSchemeType || (TokenSchemeType = {}));
exports.TokenSchemeType = TokenSchemeType;
/**
 * The base class for token schemes.
 */
class TokenScheme {
    /**
     * @param type The type of token scheme.
     */
    constructor(type) {
        this.type = type;
    }
    /**
     * Get the type of token scheme.
     */
    getType() {
        return this.type;
    }
}
exports.TokenScheme = TokenScheme;
/**
 * A simple token scheme.
 */
class SimpleTokenScheme extends TokenScheme {
    /**
     * @param mintedTokens The number of tokens that were minted.
     * @param meltedTokens The number of tokens that were melted.
     * @param maximumSupply The maximum supply of the token.
     */
    constructor(mintedTokens, meltedTokens, maximumSupply) {
        super(TokenSchemeType.Simple);
        if (typeof mintedTokens === 'bigint') {
            this.mintedTokens = mintedTokens;
        }
        else if (mintedTokens) {
            this.mintedTokens = (0, hex_encoding_1.hexToBigInt)(mintedTokens);
        }
        else {
            this.mintedTokens = BigInt(0);
        }
        if (typeof meltedTokens === 'bigint') {
            this.meltedTokens = meltedTokens;
        }
        else if (meltedTokens) {
            this.meltedTokens = (0, hex_encoding_1.hexToBigInt)(meltedTokens);
        }
        else {
            this.meltedTokens = BigInt(0);
        }
        if (typeof maximumSupply === 'bigint') {
            this.maximumSupply = maximumSupply;
        }
        else if (maximumSupply) {
            this.maximumSupply = (0, hex_encoding_1.hexToBigInt)(maximumSupply);
        }
        else {
            this.maximumSupply = BigInt(0);
        }
    }
    /**
     * Get the amount of tokens minted.
     */
    getMintedTokens() {
        return this.mintedTokens;
    }
    /**
     * Get the amount of tokens melted.
     */
    getMeltedTokens() {
        return this.meltedTokens;
    }
    /**
     * Get the maximum supply of tokens.
     */
    getMaximumSupply() {
        return this.maximumSupply;
    }
}
__decorate([
    (0, class_transformer_1.Transform)((value) => (0, hex_encoding_1.hexToBigInt)(value.value)),
    __metadata("design:type", typeof BigInt === "function" ? BigInt : Object)
], SimpleTokenScheme.prototype, "mintedTokens", void 0);
__decorate([
    (0, class_transformer_1.Transform)((value) => (0, hex_encoding_1.hexToBigInt)(value.value)),
    __metadata("design:type", typeof BigInt === "function" ? BigInt : Object)
], SimpleTokenScheme.prototype, "meltedTokens", void 0);
__decorate([
    (0, class_transformer_1.Transform)((value) => (0, hex_encoding_1.hexToBigInt)(value.value)),
    __metadata("design:type", typeof BigInt === "function" ? BigInt : Object)
], SimpleTokenScheme.prototype, "maximumSupply", void 0);
exports.SimpleTokenScheme = SimpleTokenScheme;
const TokenSchemeDiscriminator = {
    property: 'type',
    subTypes: [
        { value: SimpleTokenScheme, name: TokenSchemeType.Simple },
    ],
};
exports.TokenSchemeDiscriminator = TokenSchemeDiscriminator;
//# sourceMappingURL=token-scheme.js.map